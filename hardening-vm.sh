#!/usr/bin/env bash
set -euo pipefail

# ===============================
# Defaults (shown as fallback prompts)
# ===============================
DEFAULT_LAN_SSH_CIDR="192.168.1.0/24"
DEFAULT_VPN_SSH_CIDR="192.168.254.0/24"
DEFAULT_TIMEZONE="Europe/London"

OFFER_APT_SOURCES_CLEANUP=true
PROFILE_PATH="/etc/hardening-profile.conf"

# ===============================
# Effective config (may be overridden by profile; may be prompted)
# ===============================
TIMEZONE=""
LAN_SSH_CIDR=""
VPN_SSH_CIDR=""
declare -a PUBLIC_ALLOW_RULES=()

# ===============================
# Helpers
# ===============================
need_cmd() { command -v "$1" >/dev/null 2>&1 || { echo "ERROR: missing required command: $1"; exit 1; }; }

confirm_yn() {
  local ans=""
  while true; do
    read -r -p "$1 [y/N]: " ans
    case "${ans}" in
      [yY]|[yY][eE][sS]) return 0 ;;
      ""|[nN]|[nN][oO])  return 1 ;;
      *) echo "Please enter y or n." ;;
    esac
  done
}

run_step() {
  local name="$1"; shift
  echo
  echo "==> $name"
  if "$@"; then
    echo "OK: $name"
  else
    echo "FAIL: $name"
    exit 1
  fi
}

prompt_with_default() {
  local varname="$1"
  local prompt="$2"
  local current="$3"
  local value=""
  read -r -p "${prompt} [${current}]: " value
  value="${value#"${value%%[![:space:]]*}"}"
  value="${value%"${value##*[![:space:]]}"}"
  if [[ -n "$value" ]]; then
    printf -v "${varname}" '%s' "${value}"
  else
    printf -v "${varname}" '%s' "${current}"
  fi
}

validate_cidr() {
  local cidr="$1"
  [[ "$cidr" =~ ^([0-9]{1,3}\.){3}[0-9]{1,3}/([0-9]|[12][0-9]|3[0-2])$ ]]
}

array_contains() { local n="$1"; shift; for x in "$@"; do [[ "$x" == "$n" ]] && return 0; done; return 1; }
array_add_unique() { local v="$1"; array_contains "$v" "${PUBLIC_ALLOW_RULES[@]}" || PUBLIC_ALLOW_RULES+=( "$v" ); }

# ===============================
# Profile
# ===============================
load_profile_if_present() {
  if [[ -f "${PROFILE_PATH}" ]]; then
    echo "Profile detected: ${PROFILE_PATH}"
    echo "Loading profile..."

    local tmp
    tmp="$(mktemp)"
    # Read root-only profile via sudo, then source as current user
    sudo cat "${PROFILE_PATH}" > "${tmp}"
    # shellcheck disable=SC1090
    source "${tmp}"
    rm -f "${tmp}"

    echo "Profile loaded."
  else
    echo "No profile found at ${PROFILE_PATH}."
  fi

  # Ensure PUBLIC_ALLOW_RULES is an array even if profile/mistakes define it differently
  if ! declare -p PUBLIC_ALLOW_RULES >/dev/null 2>&1; then
    declare -a PUBLIC_ALLOW_RULES=()
  else
    # If it exists but isn't an array, convert safely
    if ! declare -p PUBLIC_ALLOW_RULES | grep -q 'declare \-a'; then
      local tmpv="${PUBLIC_ALLOW_RULES:-}"
      unset PUBLIC_ALLOW_RULES
      declare -a PUBLIC_ALLOW_RULES=()
      [[ -n "$tmpv" ]] && PUBLIC_ALLOW_RULES+=( "$tmpv" )
    fi
  fi
}

ensure_required_inputs() {
  if [[ -z "${TIMEZONE:-}" ]]; then
    prompt_with_default TIMEZONE "Timezone" "${DEFAULT_TIMEZONE}"
  fi

  if [[ -z "${LAN_SSH_CIDR:-}" ]]; then
    while true; do
      prompt_with_default LAN_SSH_CIDR "LAN subnet allowed for SSH (CIDR)" "${DEFAULT_LAN_SSH_CIDR}"
      validate_cidr "${LAN_SSH_CIDR}" && break
      echo "Invalid CIDR. Example: ${DEFAULT_LAN_SSH_CIDR}"
    done
  fi

  if [[ -z "${VPN_SSH_CIDR:-}" ]]; then
    while true; do
      prompt_with_default VPN_SSH_CIDR "VPN subnet allowed for SSH (CIDR)" "${DEFAULT_VPN_SSH_CIDR}"
      validate_cidr "${VPN_SSH_CIDR}" && break
      echo "Invalid CIDR. Example: ${DEFAULT_VPN_SSH_CIDR}"
    done
  fi
}

save_profile() {
  echo
  echo "Profile save preview (will write to ${PROFILE_PATH}):"
  echo "  TIMEZONE=${TIMEZONE}"
  echo "  LAN_SSH_CIDR=${LAN_SSH_CIDR}"
  echo "  VPN_SSH_CIDR=${VPN_SSH_CIDR}"
  if (( ${#PUBLIC_ALLOW_RULES[@]} > 0 )); then
    echo "  PUBLIC_ALLOW_RULES:"
    for p in "${PUBLIC_ALLOW_RULES[@]}"; do echo "    - ${p}"; done
  else
    echo "  PUBLIC_ALLOW_RULES: (none)"
  fi
  echo

  confirm_yn "Save these settings to ${PROFILE_PATH}?" || { echo "Skipped saving profile."; return 0; }

  local tmp
  tmp="$(mktemp)"
  {
    echo "# Generated by hardening-vm.sh on $(date -Is)"
    echo "# This file is bash-sourceable."
    echo
    printf 'TIMEZONE=%q\n' "${TIMEZONE}"
    printf 'LAN_SSH_CIDR=%q\n' "${LAN_SSH_CIDR}"
    printf 'VPN_SSH_CIDR=%q\n' "${VPN_SSH_CIDR}"
    echo "PUBLIC_ALLOW_RULES=("
    for p in "${PUBLIC_ALLOW_RULES[@]}"; do
      printf '  %q\n' "${p}"
    done
    echo ")"
    echo
  } > "${tmp}"

  sudo install -m 600 -o root -g root "${tmp}" "${PROFILE_PATH}"
  rm -f "${tmp}"
  echo "OK: saved profile to ${PROFILE_PATH}"
}

# ===============================
# UFW discovery / prompts (robust)
# ===============================
detect_ufw_public_ports() {
  command -v ufw >/dev/null 2>&1 || return 0

  local out
  out="$(sudo ufw status verbose 2>/dev/null || true)"
  echo "$out" | grep -q '^Status: active' || return 0

  echo "$out" | awk '
    BEGIN { inrules=0 }
    /^To[[:space:]]+Action[[:space:]]+From/ { inrules=1; next }
    inrules==1 && $0 ~ /ALLOW IN/ && $0 ~ /Anywhere/ { print $1 }
  ' | tr -d '\r' | grep -E '^[0-9]{1,5}/(tcp|udp)$' | sort -u || true
}

prompt_import_existing_ufw_public_ports() {
  local detected=()
  mapfile -t detected < <(detect_ufw_public_ports)
  (( ${#detected[@]} > 0 )) || return 0

  echo
  echo "Detected existing UFW public allow rules (ALLOW IN Anywhere):"
  for p in "${detected[@]}"; do echo "  - ${p}"; done
  echo

  if confirm_yn "Import these into this run (and into the profile if saved)?"; then
    for p in "${detected[@]}"; do array_add_unique "$p"; done
    echo "OK: imported detected public ports."
  else
    echo "Skipped importing detected public ports."
  fi
}

prompt_additional_public_ports() {
  local input="" ports=()

  echo
  confirm_yn "Add any additional public ports (open to internet)?" || return 0

  echo "Enter <port>/<proto> e.g. 25565/tcp, 21116/udp. Blank line to finish."
  while true; do
    read -r -p "> " input
    [[ -z "$input" ]] && break
    if [[ "$input" =~ ^[0-9]{1,5}/(tcp|udp)$ ]]; then
      ports+=( "$input" )
    else
      echo "Invalid format."
    fi
  done

  (( ${#ports[@]} > 0 )) || { echo "No additional ports added."; return 0; }

  echo "Proposed additional public ports:"
  for p in "${ports[@]}"; do echo "  - $p"; done

  if confirm_yn "Confirm adding these?"; then
    for p in "${ports[@]}"; do array_add_unique "$p"; done
    echo "OK: added additional public ports."
  else
    echo "Cancelled."
  fi
}

# ===============================
# APT helpers
# ===============================
disable_repo_file() {
  local f="$1"
  [[ -f "$f" ]] || { echo "WARN: not found: $f"; return 0; }
  local new="${f}.disabled.$(date +%Y%m%d-%H%M%S)"
  echo "Disabling repo file: $f -> $new"
  sudo mv "$f" "$new"
}

find_sources_paths_from_apt_output() {
  local out_file="$1"
  grep -Eo '/etc/apt/sources\.list(\.d/[^ )]+)?' "$out_file" | sort -u || true
}

check_and_fix_malformed_sources() {
  echo "APT preflight: running apt-get update..."
  local out
  out="$(mktemp)"
  set +e
  sudo apt-get update 2>&1 | tee "$out"
  local rc="${PIPESTATUS[0]}"
  set -e

  if [[ "$rc" -eq 0 ]]; then
    echo "APT preflight OK."
    rm -f "$out"
    return 0
  fi

  echo "APT update failed."
  local files=()
  mapfile -t files < <(find_sources_paths_from_apt_output "$out")

  if (( ${#files[@]} == 0 )); then
    echo "Could not auto-identify offending file. Output:"
    cat "$out"
    rm -f "$out"
    return 1
  fi

  echo "Potential offending source file(s):"
  for f in "${files[@]}"; do echo "  - $f"; done

  if confirm_yn "Disable identified /etc/apt/sources.list.d/* entries (not /etc/apt/sources.list) and retry?"; then
    for f in "${files[@]}"; do
      [[ "$f" == "/etc/apt/sources.list" ]] && continue
      disable_repo_file "$f"
    done
    sudo apt-get update
    rm -f "$out"
    return 0
  fi

  echo "Skipped. Output:"
  cat "$out"
  rm -f "$out"
  return 1
}

detect_ubuntu_codename() { . /etc/os-release; echo "${VERSION_CODENAME:-}"; }

sources_list_contains_ubuntu_deb_lines() {
  sudo grep -Eqs '^\s*deb\s+http(s)?://(archive|security)\.ubuntu\.com/ubuntu' /etc/apt/sources.list
}

comment_out_ubuntu_lines_in_sources_list() {
  sudo sed -i \
    -e 's|^\(\s*deb\s\+http[s]\?://archive\.ubuntu\.com/ubuntu\)|# \1|g' \
    -e 's|^\(\s*deb\s\+http[s]\?://security\.ubuntu\.com/ubuntu\)|# \1|g' \
    /etc/apt/sources.list
}

create_deb822_ubuntu_sources() {
  local codename="$1"
  local target="/etc/apt/sources.list.d/ubuntu.sources"
  local keyring="/usr/share/keyrings/ubuntu-archive-keyring.gpg"
  [[ -f "$keyring" ]] || { echo "ERROR: missing keyring: $keyring"; return 1; }

  sudo tee "$target" >/dev/null <<EOF
Types: deb
URIs: http://archive.ubuntu.com/ubuntu
Suites: ${codename} ${codename}-updates ${codename}-backports
Components: main restricted universe multiverse
Signed-By: ${keyring}

Types: deb
URIs: http://security.ubuntu.com/ubuntu
Suites: ${codename}-security
Components: main restricted universe multiverse
Signed-By: ${keyring}
EOF
}

clean_up_apt_sources() {
  [[ "${OFFER_APT_SOURCES_CLEANUP}" == "true" ]] || return 0
  [[ -f /etc/apt/sources.list ]] || return 0
  sources_list_contains_ubuntu_deb_lines || return 0

  local codename
  codename="$(detect_ubuntu_codename)"
  [[ -n "$codename" ]] || { echo "WARN: cannot detect codename; skipping APT cleanup."; return 0; }

  echo
  echo "APT cleanup available (remove 'Missing Signed-By' warnings):"
  echo "  - create /etc/apt/sources.list.d/ubuntu.sources (Deb822 + Signed-By)"
  echo "  - comment Ubuntu lines in /etc/apt/sources.list"
  confirm_yn "Apply this cleanup now?" || { echo "Skipped APT cleanup."; return 0; }

  create_deb822_ubuntu_sources "$codename"
  comment_out_ubuntu_lines_in_sources_list
  sudo apt-get update
}

# ===============================
# Service helpers
# ===============================
reload_ssh_service() {
  if systemctl list-unit-files 2>/dev/null | grep -qE '^ssh\.service'; then
    sudo systemctl reload ssh || sudo systemctl restart ssh
  elif systemctl list-unit-files 2>/dev/null | grep -qE '^sshd\.service'; then
    sudo systemctl reload sshd || sudo systemctl restart sshd
  elif systemctl list-units --all 2>/dev/null | grep -qE '^ssh\.service'; then
    sudo systemctl reload ssh || sudo systemctl restart ssh
  elif systemctl list-units --all 2>/dev/null | grep -qE '^sshd\.service'; then
    sudo systemctl reload sshd || sudo systemctl restart sshd
  elif [[ -f /lib/systemd/system/ssh.service || -f /usr/lib/systemd/system/ssh.service ]]; then
    sudo systemctl reload ssh || sudo systemctl restart ssh
  elif [[ -f /lib/systemd/system/sshd.service || -f /usr/lib/systemd/system/sshd.service ]]; then
    sudo systemctl reload sshd || sudo systemctl restart sshd
  else
    echo "WARN: neither ssh.service nor sshd.service found; reload skipped"
  fi
}

start_qemu_guest_agent() {
  sudo systemctl start qemu-guest-agent.service || true
  sudo systemctl enable qemu-guest-agent.service 2>/dev/null || true
  sudo systemctl --no-pager --full status qemu-guest-agent.service || true
}

# ===============================
# Preflight scans (before Proceed?)
# ===============================
show_preflight_bundle() {
  echo
  echo "========== PREFLIGHT SUMMARY =========="
  echo "OS / init:"
  if [[ -f /etc/os-release ]]; then
    # shellcheck disable=SC1091
    . /etc/os-release
    echo "  - ${PRETTY_NAME:-unknown} (${VERSION_CODENAME:-unknown})"
  else
    echo "  - /etc/os-release not found"
  fi
  echo "  - PID 1: $(ps -p 1 -o comm= 2>/dev/null || echo unknown)"

  echo "Network:"
  echo "  - Default route:"
  ip -4 route show default 2>/dev/null | sed 's/^/      /' || echo "      (none)"
  echo "  - IPv4 addresses:"
  ip -4 addr show 2>/dev/null | sed 's/^/      /' || echo "      (none)"
  echo "  - Planned SSH allowlists:"
  echo "      * LAN: ${LAN_SSH_CIDR}"
  echo "      * VPN: ${VPN_SSH_CIDR}"

  echo "UFW:"
  if command -v ufw >/dev/null 2>&1; then
    local status
    status="$(sudo ufw status verbose 2>/dev/null || true)"
    if echo "$status" | grep -q '^Status: active'; then
      echo "  - ufw is active"
      local detected=()
      mapfile -t detected < <(detect_ufw_public_ports)
      if (( ${#detected[@]} > 0 )); then
        echo "  - Existing public allow rules detected (ALLOW IN Anywhere):"
        for p in "${detected[@]}"; do echo "      * ${p}"; done
      else
        echo "  - No existing public allow rules detected."
      fi
      echo "  - Current ufw status (verbose):"
      echo "$status" | sed 's/^/      /'
    else
      echo "  - ufw is inactive"
    fi
  else
    echo "  - ufw not installed (script will install it)."
  fi

  echo "SSH:"
  if command -v sshd >/dev/null 2>&1; then
    sudo sshd -t >/dev/null 2>&1 && echo "  - sshd config syntax: OK (sshd -t)" || echo "  - sshd config syntax: FAIL (sshd -t)"
  else
    echo "  - sshd binary not found (openssh-server may not be installed yet)"
  fi
  if systemctl list-unit-files 2>/dev/null | grep -qE '^ssh\.service|^sshd\.service'; then
    echo "  - ssh unit file present"
  else
    echo "  - ssh unit file not detected in list-unit-files (may still exist; script handles this)"
  fi

  echo "Disk / memory:"
  df -h / 2>/dev/null | sed 's/^/      /' || true
  command -v free >/dev/null 2>&1 && free -h 2>/dev/null | sed 's/^/      /' || true

  echo "APT sources (inventory only):"
  sudo ls -1 /etc/apt/sources.list /etc/apt/sources.list.d/* 2>/dev/null | sed 's/^/  - /' || echo "  - (none?)"

  echo "======================================="
  echo
  echo "Note: This script resets UFW rules (ufw --force reset)."
  echo "      If your SSH CIDRs are wrong, you could lock yourself out."
}

# ===============================
# Main
# ===============================
need_cmd sudo
need_cmd systemctl
need_cmd sed
need_cmd grep
need_cmd apt-get
need_cmd ip
need_cmd ps
need_cmd df

if [[ "$EUID" -eq 0 ]]; then
  echo "Run as a normal user with sudo, not root."
  exit 1
fi

# Warm up sudo (so you don't get interrupted by prompts mid-script)
sudo -v

load_profile_if_present
ensure_required_inputs

show_preflight_bundle

echo "Effective settings for this run:"
echo "  TIMEZONE:     ${TIMEZONE}"
echo "  LAN_SSH_CIDR: ${LAN_SSH_CIDR}"
echo "  VPN_SSH_CIDR: ${VPN_SSH_CIDR}"
echo

confirm_yn "Proceed to apply hardening?" || { echo "Aborted."; exit 0; }

# Import existing UFW public ports BEFORE saving profile
prompt_import_existing_ufw_public_ports
prompt_additional_public_ports

echo
echo "Final public ports to open (Anywhere):"
if (( ${#PUBLIC_ALLOW_RULES[@]} > 0 )); then
  for p in "${PUBLIC_ALLOW_RULES[@]}"; do echo "  - ${p}"; done
else
  echo "  (none)"
fi

if confirm_yn "Save these settings to ${PROFILE_PATH} for future runs?"; then
  run_step "Save hardening profile" save_profile
fi

run_step "Set timezone" sudo timedatectl set-timezone "${TIMEZONE}"

run_step "APT preflight (fix malformed sources if needed)" check_and_fix_malformed_sources

run_step "Install baseline packages" bash -c '
sudo apt-get update
sudo apt-get install -y ufw qemu-guest-agent unattended-upgrades openssh-server
'

run_step "QEMU guest agent (start; enable best-effort)" start_qemu_guest_agent

run_step "Enable serial console" sudo systemctl enable --now serial-getty@ttyS0

run_step "Configure GRUB for serial console" bash -c '
set -e
GRUB=/etc/default/grub
sudo sed -i \
  -e "s/^GRUB_CMDLINE_LINUX=.*/GRUB_CMDLINE_LINUX=\"console=tty0 console=ttyS0,115200n8\"/" \
  -e "s/^GRUB_TERMINAL=.*/GRUB_TERMINAL=\"serial console\"/" \
  -e "s/^GRUB_SERIAL_COMMAND=.*/GRUB_SERIAL_COMMAND=\"serial --speed=115200 --unit=0 --word=8 --parity=no --stop=1\"/" \
  "$GRUB" || true

grep -q GRUB_CMDLINE_LINUX "$GRUB" || echo "GRUB_CMDLINE_LINUX=\"console=tty0 console=ttyS0,115200n8\"" | sudo tee -a "$GRUB" >/dev/null
grep -q GRUB_TERMINAL "$GRUB" || echo "GRUB_TERMINAL=\"serial console\"" | sudo tee -a "$GRUB" >/dev/null
grep -q GRUB_SERIAL_COMMAND "$GRUB" || echo "GRUB_SERIAL_COMMAND=\"serial --speed=115200 --unit=0 --word=8 --parity=no --stop=1\"" | sudo tee -a "$GRUB" >/dev/null
sudo update-grub
'

run_step "Configure SSH (disable root, enable password auth)" bash -c '
set -e
SSHD=/etc/ssh/sshd_config

if command -v sshd >/dev/null 2>&1; then
  sudo sshd -t || true
fi

if grep -qE "^\s*#?\s*PermitRootLogin" "$SSHD"; then
  sudo sed -i "s/^\s*#\?\s*PermitRootLogin.*/PermitRootLogin no/" "$SSHD"
else
  echo "PermitRootLogin no" | sudo tee -a "$SSHD" >/dev/null
fi

if grep -qE "^\s*#?\s*PasswordAuthentication" "$SSHD"; then
  sudo sed -i "s/^\s*#\?\s*PasswordAuthentication.*/PasswordAuthentication yes/" "$SSHD"
else
  echo "PasswordAuthentication yes" | sudo tee -a "$SSHD" >/dev/null
fi

if grep -qE "^\s*#?\s*UsePAM" "$SSHD"; then
  sudo sed -i "s/^\s*#\?\s*UsePAM.*/UsePAM yes/" "$SSHD"
else
  echo "UsePAM yes" | sudo tee -a "$SSHD" >/dev/null
fi

if command -v sshd >/dev/null 2>&1; then
  sudo sshd -t
fi
'

run_step "Reload SSH service" reload_ssh_service

run_step "Configure UFW" bash -c '
set -e
sudo ufw --force reset
sudo ufw default deny incoming
sudo ufw default allow outgoing

sudo ufw allow from "'"${LAN_SSH_CIDR}"'" to any port 22 proto tcp
sudo ufw allow from "'"${VPN_SSH_CIDR}"'" to any port 22 proto tcp
'

if (( ${#PUBLIC_ALLOW_RULES[@]} > 0 )); then
  for p in "${PUBLIC_ALLOW_RULES[@]}"; do
    run_step "UFW allow public ${p}" sudo ufw allow "${p}"
  done
fi

run_step "Enable UFW + show status" bash -c '
set -e
sudo ufw logging low
sudo ufw --force enable
sudo ufw status verbose
'

run_step "APT sources cleanup (optional)" clean_up_apt_sources

echo
echo "Baseline applied successfully."
echo "RECOMMENDED: reboot the VM so GRUB serial settings take effect:"
echo "  sudo reboot"